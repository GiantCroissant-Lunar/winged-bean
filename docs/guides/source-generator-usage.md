# Source Generator Usage Guide

This guide explains how to use the WingedBean source generators to automatically generate service proxy implementations.

## Overview

WingedBean includes a Roslyn source generator (`WingedBean.SourceGenerators.Proxy`) that automatically generates proxy service implementations based on attributes. This eliminates boilerplate code and ensures type-safe service resolution from the registry.

## Source Generator: ProxyServiceGenerator

The `ProxyServiceGenerator` generates proxy implementations for services that delegate to the service registry.

### Location

```
framework/src/WingedBean.SourceGenerators.Proxy/
├── ProxyServiceGenerator.cs              # Main generator implementation
└── WingedBean.SourceGenerators.Proxy.csproj
```

### Target Framework

- **Framework**: `.NET Standard 2.0` (required for Roslyn compatibility)
- **Usage**: Any project targeting netstandard2.1 or net8.0

## Using the Proxy Generator

### Step 1: Add Analyzer Reference

Add the source generator to your project as an analyzer:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <!-- Reference the source generator as an analyzer -->
    <ProjectReference Include="../../framework/src/WingedBean.SourceGenerators.Proxy/WingedBean.SourceGenerators.Proxy.csproj"
                      OutputItemType="Analyzer"
                      ReferenceOutputAssembly="false" />
    
    <!-- Reference contracts for interfaces and attributes -->
    <ProjectReference Include="../../framework/src/WingedBean.Contracts.Core/WingedBean.Contracts.Core.csproj" />
  </ItemGroup>
</Project>
```

**Key points:**
- `OutputItemType="Analyzer"` - Treats the project as a source generator
- `ReferenceOutputAssembly="false"` - Generator runs at compile time only

### Step 2: Define Your Service Interface

Create a service interface in a Tier 1 contract project:

```csharp
// In WingedBean.Contracts.Core or similar
namespace WingedBean.Contracts.Core;

public interface IMyService
{
    string GetData();
    Task<int> ProcessAsync(string input);
    void DoSomething();
}
```

### Step 3: Create Partial Class with Attributes

Create a partial class annotated with `[RealizeService]`:

```csharp
using WingedBean.Contracts.Core;

namespace MyApp.Services;

// Mark the class as partial so the generator can add implementation
[RealizeService(typeof(IMyService))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class MyServiceProxy : IMyService
{
    private readonly IServiceRegistry _registry;
    
    // Constructor must accept IServiceRegistry
    public MyServiceProxy(IServiceRegistry registry)
    {
        _registry = registry;
    }
    
    // No need to implement interface members - the generator does it!
}
```

### Step 4: Build and Use

Build your project and the generator will create `MyServiceProxy.g.cs`:

```csharp
// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using WingedBean.Contracts.Core;

namespace MyApp.Services
{
    public partial class MyServiceProxy
    {
        public string GetData()
        {
            var service = _registry.Get<WingedBean.Contracts.Core.IMyService>(
                global::WingedBean.Contracts.Core.SelectionMode.HighestPriority);
            return service.GetData();
        }

        public Task<int> ProcessAsync(string input)
        {
            var service = _registry.Get<WingedBean.Contracts.Core.IMyService>(
                global::WingedBean.Contracts.Core.SelectionMode.HighestPriority);
            return service.ProcessAsync(input);
        }

        public void DoSomething()
        {
            var service = _registry.Get<WingedBean.Contracts.Core.IMyService>(
                global::WingedBean.Contracts.Core.SelectionMode.HighestPriority);
            service.DoSomething();
        }
    }
}
```

Now you can use it:

```csharp
var registry = new ActualRegistry();
// Register actual implementations...
registry.Register<IMyService>(new MyServiceImpl(), priority: 100);

// Use the proxy
var proxy = new MyServiceProxy(registry);
string data = proxy.GetData();  // Automatically delegates to highest priority implementation
```

## Attributes

### `[RealizeService]`

Marks a partial class for proxy generation.

**Syntax:**
```csharp
[RealizeService(typeof(IServiceInterface))]
```

**Parameters:**
- `serviceType` - The interface type to implement (must be an interface)

**Requirements:**
- Class must be `partial`
- Class must have a constructor accepting `IServiceRegistry`
- Class should implement the interface (for IntelliSense)

### `[SelectionStrategy]`

Specifies how to select the service from the registry.

**Syntax:**
```csharp
[SelectionStrategy(SelectionMode.HighestPriority)]
```

**Parameters:**
- `mode` - One of:
  - `SelectionMode.One` - Get any single implementation
  - `SelectionMode.HighestPriority` - Get implementation with highest priority (default)
  - `SelectionMode.All` - Get all implementations (returns collection)

**Default:** `HighestPriority` if not specified

## Supported Interface Members

The generator supports all standard interface members:

### Methods

```csharp
public interface IMyService
{
    // Void method
    void DoWork();
    
    // Return value
    string GetData();
    
    // Async methods
    Task DoWorkAsync();
    Task<int> GetDataAsync();
    
    // Generic methods
    T GetValue<T>(string key);
    
    // Methods with parameters
    void Process(string input, int count = 10);
}
```

### Properties

```csharp
public interface IMyService
{
    // Read-only property
    string Name { get; }
    
    // Read-write property
    int Count { get; set; }
    
    // Write-only property (rare)
    string Password { set; }
}
```

### Events

```csharp
public interface IMyService
{
    event EventHandler DataChanged;
    event EventHandler<CustomEventArgs> CustomEvent;
}
```

## Advanced Usage

### Multiple Service Proxies

You can create multiple proxies for the same service with different selection strategies:

```csharp
// Get highest priority implementation
[RealizeService(typeof(ILogger))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class DefaultLogger : ILogger
{
    private readonly IServiceRegistry _registry;
    public DefaultLogger(IServiceRegistry registry) => _registry = registry;
}

// Get all implementations (for broadcasting)
[RealizeService(typeof(ILogger))]
[SelectionStrategy(SelectionMode.All)]
public partial class BroadcastLogger : ILogger
{
    private readonly IServiceRegistry _registry;
    public BroadcastLogger(IServiceRegistry registry) => _registry = registry;
    
    // Note: When SelectionMode.All, methods need to iterate over all implementations
    // This is a future enhancement - currently use HighestPriority or One
}
```

### Generic Constraints

The generator properly handles generic type constraints:

```csharp
public interface IRepository<T> where T : class
{
    T? GetById(int id);
    IEnumerable<T> GetAll();
}

[RealizeService(typeof(IRepository<>))]
public partial class RepositoryProxy<T> : IRepository<T> where T : class
{
    private readonly IServiceRegistry _registry;
    public RepositoryProxy(IServiceRegistry registry) => _registry = registry;
}
```

### Nullable Reference Types

The generator fully supports nullable reference types:

```csharp
public interface IDataService
{
    string? GetOptionalValue(string key);
    string GetRequiredValue(string key);
}
```

Generated code preserves nullability annotations:

```csharp
public string? GetOptionalValue(string key)
{
    var service = _registry.Get<IDataService>(SelectionMode.HighestPriority);
    return service.GetOptionalValue(key);
}

public string GetRequiredValue(string key)
{
    var service = _registry.Get<IDataService>(SelectionMode.HighestPriority);
    return service.GetRequiredValue(key);
}
```

## Viewing Generated Code

### Visual Studio

1. Expand project in Solution Explorer
2. Expand "Dependencies" → "Analyzers"
3. Expand "WingedBean.SourceGenerators.Proxy"
4. View generated `.g.cs` files

### Rider

1. Right-click project → "Navigate" → "Go to Generated Code"
2. Select the source generator
3. View generated files

### Command Line

Generated files are in `obj/` folder:

```bash
find obj -name "*.g.cs"
```

### MSBuild Property

Add to `.csproj` to emit generated files to disk:

```xml
<PropertyGroup>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\GeneratedFiles</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

Then check `obj/GeneratedFiles/` folder.

## Troubleshooting

### Generator Not Running

**Symptoms:**
- No `.g.cs` files generated
- Compilation errors about missing implementations

**Solutions:**

1. **Verify project reference:**
   ```xml
   <ProjectReference Include="path/to/WingedBean.SourceGenerators.Proxy.csproj"
                     OutputItemType="Analyzer"
                     ReferenceOutputAssembly="false" />
   ```

2. **Clean and rebuild:**
   ```bash
   dotnet clean
   dotnet build
   ```

3. **Check generator version:**
   ```bash
   dotnet build /p:GeneratorExecutionLog=true
   ```

### Compilation Errors in Generated Code

**Symptoms:**
- Errors in `.g.cs` files
- Type not found errors

**Solutions:**

1. **Add missing using statements** to your partial class file (they're inherited by generated code)

2. **Use fully qualified names** in interface definitions

3. **Ensure IServiceRegistry is accessible:**
   ```csharp
   using WingedBean.Contracts.Core;
   ```

### Performance Issues

**Symptoms:**
- Slow builds
- High CPU during compilation

**Solutions:**

1. **Limit generator scope** with conditional compilation:
   ```xml
   <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
     <DisableSourceGenerators>true</DisableSourceGenerators>
   </PropertyGroup>
   ```

2. **Use build caching** (enabled by default in .NET SDK)

## Testing Generated Code

### Unit Testing

Generated proxy code can be tested like any other code:

```csharp
[Fact]
public void ProxyDelegatesCorrectly()
{
    // Arrange
    var mockService = new Mock<IMyService>();
    mockService.Setup(s => s.GetData()).Returns("test");
    
    var registry = new ActualRegistry();
    registry.Register<IMyService>(mockService.Object);
    
    var proxy = new MyServiceProxy(registry);
    
    // Act
    var result = proxy.GetData();
    
    // Assert
    Assert.Equal("test", result);
    mockService.Verify(s => s.GetData(), Times.Once);
}
```

### Integration Testing

Test with real implementations:

```csharp
[Fact]
public void ProxyWorksWithRealRegistry()
{
    // Arrange
    var registry = new ActualRegistry();
    registry.Register<IMyService>(new RealServiceImpl(), priority: 100);
    
    var proxy = new MyServiceProxy(registry);
    
    // Act & Assert
    Assert.NotNull(proxy.GetData());
}
```

## Best Practices

1. **Always mark proxy classes as `partial`**
   - Required for generator to add implementation

2. **Implement the interface explicitly**
   - Provides IntelliSense in IDE
   - Documents intent

3. **Use descriptive proxy names**
   - End with "Proxy" or "Facade" for clarity
   - Example: `ConfigServiceProxy`, `AudioServiceFacade`

4. **Keep one proxy per service**
   - Don't create multiple proxies for the same service (unless different strategies)

5. **Document selection strategy**
   - Comment why you chose a particular `SelectionMode`

6. **Test proxies**
   - Write unit tests to verify delegation works correctly

## Examples

### Example 1: Configuration Service Proxy

```csharp
[RealizeService(typeof(IConfigService))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class ConfigServiceProxy : IConfigService
{
    private readonly IServiceRegistry _registry;
    
    public ConfigServiceProxy(IServiceRegistry registry)
    {
        _registry = registry;
    }
}
```

### Example 2: Audio Service Proxy with Events

```csharp
[RealizeService(typeof(IAudioService))]
public partial class AudioServiceProxy : IAudioService
{
    private readonly IServiceRegistry _registry;
    
    public AudioServiceProxy(IServiceRegistry registry)
    {
        _registry = registry;
    }
}

// IAudioService interface
public interface IAudioService
{
    void Play(string soundId);
    void Stop();
    event EventHandler<AudioEventArgs> SoundPlayed;
}
```

### Example 3: Generic Repository Proxy

```csharp
[RealizeService(typeof(IRepository<>))]
public partial class RepositoryProxy<T> : IRepository<T> where T : class, new()
{
    private readonly IServiceRegistry _registry;
    
    public RepositoryProxy(IServiceRegistry registry)
    {
        _registry = registry;
    }
}
```

## Related Documentation

- [Framework Targeting Guide](./framework-targeting-guide.md)
- [RFC-0005: Target Framework Compliance](../rfcs/0005-target-framework-compliance.md)
- [Service Registry Documentation](../rfcs/0002-service-platform-core-4-tier-architecture.md)

## References

- [Roslyn Source Generators Overview](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)
- [C# Source Generators Cookbook](https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md)
- [Incremental Generators](https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md)
