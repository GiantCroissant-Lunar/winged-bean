using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WingedBean.SourceGenerators.Proxy;

[Generator]
public class ProxyServiceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ProxyServiceSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ProxyServiceSyntaxReceiver receiver)
            return;

        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidateClass);
            
            if (classSymbol == null)
                continue;

            // Find RealizeService attribute
            var realizeServiceAttr = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "RealizeServiceAttribute");
            
            if (realizeServiceAttr == null)
                continue;

            // Get the service type from the attribute
            if (realizeServiceAttr.ConstructorArguments.Length == 0)
                continue;

            var serviceType = realizeServiceAttr.ConstructorArguments[0].Value as INamedTypeSymbol;
            if (serviceType == null)
                continue;

            // Find SelectionStrategy attribute
            var selectionStrategyAttr = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "SelectionStrategyAttribute");
            
            var selectionMode = "HighestPriority";
            if (selectionStrategyAttr != null && selectionStrategyAttr.ConstructorArguments.Length > 0)
            {
                // Get the enum value as integer and convert to enum member name
                var enumValue = selectionStrategyAttr.ConstructorArguments[0].Value;
                if (enumValue is int intValue)
                {
                    // Map enum value to name: 0=One, 1=HighestPriority, 2=All
                    selectionMode = intValue switch
                    {
                        0 => "One",
                        1 => "HighestPriority",
                        2 => "All",
                        _ => "HighestPriority"
                    };
                }
            }

            // Generate the proxy implementation
            var source = GenerateProxyImplementation(classSymbol, serviceType, selectionMode);
            context.AddSource($"{classSymbol.Name}.g.cs", source);
        }
    }

    private string GenerateProxyImplementation(INamedTypeSymbol classSymbol, INamedTypeSymbol serviceType, string selectionMode)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using WingedBean.Contracts.Core;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");

        // Generate method implementations
        var members = serviceType.GetMembers();
        foreach (var member in members)
        {
            if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
            {
                GenerateMethodImplementation(sb, method, serviceType, selectionMode);
            }
            else if (member is IPropertySymbol property)
            {
                GeneratePropertyImplementation(sb, property, serviceType, selectionMode);
            }
            else if (member is IEventSymbol eventSymbol)
            {
                GenerateEventImplementation(sb, eventSymbol, serviceType, selectionMode);
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateMethodImplementation(StringBuilder sb, IMethodSymbol method, INamedTypeSymbol serviceType, string selectionMode)
    {
        // Build method signature with proper nullable reference type handling
        var returnType = method.ReturnType.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
        ));
        var methodName = method.Name;
        
        // Build type parameters
        var typeParams = method.TypeParameters.Length > 0
            ? $"<{string.Join(", ", method.TypeParameters.Select(tp => tp.Name))}>"
            : "";
        
        // Build parameters with proper nullable handling
        var parameters = string.Join(", ", method.Parameters.Select(p =>
        {
            var paramType = p.Type.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
            ));
            var paramName = p.Name;
            var defaultValue = p.HasExplicitDefaultValue ? $" = {FormatDefaultValue(p.ExplicitDefaultValue, p.Type)}" : "";
            return $"{paramType} {paramName}{defaultValue}";
        }));

        // Build type constraints
        var constraints = new List<string>();
        foreach (var typeParam in method.TypeParameters)
        {
            var constraintClauses = new List<string>();
            if (typeParam.HasReferenceTypeConstraint)
                constraintClauses.Add("class");
            if (typeParam.HasValueTypeConstraint)
                constraintClauses.Add("struct");
            if (typeParam.HasConstructorConstraint)
                constraintClauses.Add("new()");
            foreach (var constraintType in typeParam.ConstraintTypes)
                constraintClauses.Add(constraintType.ToDisplayString(new SymbolDisplayFormat(
                    typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
                )));
            
            if (constraintClauses.Any())
                constraints.Add($"where {typeParam.Name} : {string.Join(", ", constraintClauses)}");
        }

        var constraintString = constraints.Any() ? "\n            " + string.Join("\n            ", constraints) : "";

        // Generate method body
        sb.AppendLine($"        public {returnType} {methodName}{typeParams}({parameters}){constraintString}");
        sb.AppendLine("        {");
        
        var serviceTypeDisplay = serviceType.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
        ));
        sb.AppendLine($"            var service = _registry.Get<{serviceTypeDisplay}>(global::WingedBean.Contracts.Core.SelectionMode.{selectionMode});");
        
        // Build method call arguments
        var arguments = string.Join(", ", method.Parameters.Select(p => p.Name));
        
        if (method.ReturnsVoid)
        {
            sb.AppendLine($"            service.{methodName}{typeParams}({arguments});");
        }
        else
        {
            sb.AppendLine($"            return service.{methodName}{typeParams}({arguments});");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GeneratePropertyImplementation(StringBuilder sb, IPropertySymbol property, INamedTypeSymbol serviceType, string selectionMode)
    {
        var propertyType = property.Type.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
        ));
        var propertyName = property.Name;
        var serviceTypeDisplay = serviceType.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
        ));

        sb.AppendLine($"        public {propertyType} {propertyName}");
        sb.AppendLine("        {");
        
        if (property.GetMethod != null)
        {
            sb.AppendLine("            get");
            sb.AppendLine("            {");
            sb.AppendLine($"                var service = _registry.Get<{serviceTypeDisplay}>(global::WingedBean.Contracts.Core.SelectionMode.{selectionMode});");
            sb.AppendLine($"                return service.{propertyName};");
            sb.AppendLine("            }");
        }
        
        if (property.SetMethod != null)
        {
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                var service = _registry.Get<{serviceTypeDisplay}>(global::WingedBean.Contracts.Core.SelectionMode.{selectionMode});");
            sb.AppendLine($"                service.{propertyName} = value;");
            sb.AppendLine("            }");
        }
        
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private void GenerateEventImplementation(StringBuilder sb, IEventSymbol eventSymbol, INamedTypeSymbol serviceType, string selectionMode)
    {
        var eventType = eventSymbol.Type.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
        ));
        var eventName = eventSymbol.Name;
        var serviceTypeDisplay = serviceType.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces
        ));

        sb.AppendLine($"        public event {eventType} {eventName}");
        sb.AppendLine("        {");
        sb.AppendLine("            add");
        sb.AppendLine("            {");
        sb.AppendLine($"                var service = _registry.Get<{serviceTypeDisplay}>(global::WingedBean.Contracts.Core.SelectionMode.{selectionMode});");
        sb.AppendLine($"                service.{eventName} += value;");
        sb.AppendLine("            }");
        sb.AppendLine("            remove");
        sb.AppendLine("            {");
        sb.AppendLine($"                var service = _registry.Get<{serviceTypeDisplay}>(global::WingedBean.Contracts.Core.SelectionMode.{selectionMode});");
        sb.AppendLine($"                service.{eventName} -= value;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private string FormatDefaultValue(object? value, ITypeSymbol type)
    {
        if (value == null)
        {
            // Check if this is a nullable type or reference type
            if (type.IsReferenceType || type.NullableAnnotation == NullableAnnotation.Annotated)
                return "null";
            return "default";
        }
        if (value is string s)
            return $"\"{s}\"";
        if (value is bool b)
            return b ? "true" : "false";
        return value.ToString() ?? "default";
    }
}

class ProxyServiceSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) &&
            classDeclaration.AttributeLists.Count > 0)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}
